{"ast":null,"code":"// sudokuUtils.js\n\nconst isSafe = (grid, row, col, num) => {\n  for (let x = 0; x < 9; x++) {\n    if (grid[row][x] === num || grid[x][col] === num) return false;\n    const boxRow = 3 * Math.floor(row / 3) + Math.floor(x / 3);\n    const boxCol = 3 * Math.floor(col / 3) + x % 3;\n    if (grid[boxRow][boxCol] === num) return false;\n  }\n  return true;\n};\nconst solveSudoku = grid => {\n  const solve = () => {\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        if (grid[row][col] === 0) {\n          for (let num = 1; num <= 9; num++) {\n            if (isSafe(grid, row, col, num)) {\n              grid[row][col] = num;\n              if (solve()) return true;\n              grid[row][col] = 0;\n            }\n          }\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  const copiedGrid = grid.map(r => [...r]);\n  return solve() ? copiedGrid : null;\n};\n\n// Fills the board completely using backtracking\nconst generateFullBoard = () => {\n  const grid = Array(9).fill(0).map(() => Array(9).fill(0));\n  const fill = (row = 0, col = 0) => {\n    if (row === 9) return true;\n    const nextRow = col === 8 ? row + 1 : row;\n    const nextCol = col === 8 ? 0 : col + 1;\n    const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);\n    for (const num of numbers) {\n      if (isSafe(grid, row, col, num)) {\n        grid[row][col] = num;\n        if (fill(nextRow, nextCol)) return true;\n        grid[row][col] = 0;\n      }\n    }\n    return false;\n  };\n  fill();\n  return grid;\n};\nconst removeCells = (grid, count) => {\n  const puzzle = grid.map(r => [...r]);\n  let removed = 0;\n  while (removed < count) {\n    const row = Math.floor(Math.random() * 9);\n    const col = Math.floor(Math.random() * 9);\n    if (puzzle[row][col] !== 0) {\n      puzzle[row][col] = 0;\n      removed++;\n    }\n  }\n  return puzzle;\n};\n\n// Main function to generate a solvable puzzle\nconst generateSudoku = (difficulty = \"easy\") => {\n  const fullGrid = generateFullBoard();\n  let blanks;\n  switch (difficulty) {\n    case \"easy\":\n      blanks = 40;\n      break;\n    case \"medium\":\n      blanks = 50;\n      break;\n    case \"hard\":\n      blanks = 60;\n      break;\n    default:\n      blanks = 50;\n  }\n  const puzzle = removeCells(fullGrid, blanks);\n\n  // Ensure it's still solvable\n  const solvable = solveSudoku(puzzle.map(r => [...r]));\n  if (!solvable) return generateSudoku(difficulty); // Retry if not solvable\n\n  const fixedCells = puzzle.map(row => row.map(val => val !== 0));\n  return {\n    puzzle,\n    fixedCells\n  };\n};\nexport { generateSudoku, solveSudoku, isSafe };","map":{"version":3,"names":["isSafe","grid","row","col","num","x","boxRow","Math","floor","boxCol","solveSudoku","solve","copiedGrid","map","r","generateFullBoard","Array","fill","nextRow","nextCol","numbers","sort","random","removeCells","count","puzzle","removed","generateSudoku","difficulty","fullGrid","blanks","solvable","fixedCells","val"],"sources":["C:/Users/Admin/Desktop/sudoku_solver/src/sudokuUtils.js"],"sourcesContent":["// sudokuUtils.js\r\n\r\nconst isSafe = (grid, row, col, num) => {\r\n  for (let x = 0; x < 9; x++) {\r\n    if (grid[row][x] === num || grid[x][col] === num) return false;\r\n    const boxRow = 3 * Math.floor(row / 3) + Math.floor(x / 3);\r\n    const boxCol = 3 * Math.floor(col / 3) + x % 3;\r\n    if (grid[boxRow][boxCol] === num) return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nconst solveSudoku = (grid) => {\r\n  const solve = () => {\r\n    for (let row = 0; row < 9; row++) {\r\n      for (let col = 0; col < 9; col++) {\r\n        if (grid[row][col] === 0) {\r\n          for (let num = 1; num <= 9; num++) {\r\n            if (isSafe(grid, row, col, num)) {\r\n              grid[row][col] = num;\r\n              if (solve()) return true;\r\n              grid[row][col] = 0;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  const copiedGrid = grid.map(r => [...r]);\r\n  return solve() ? copiedGrid : null;\r\n};\r\n\r\n// Fills the board completely using backtracking\r\nconst generateFullBoard = () => {\r\n  const grid = Array(9).fill(0).map(() => Array(9).fill(0));\r\n\r\n  const fill = (row = 0, col = 0) => {\r\n    if (row === 9) return true;\r\n\r\n    const nextRow = col === 8 ? row + 1 : row;\r\n    const nextCol = col === 8 ? 0 : col + 1;\r\n\r\n    const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);\r\n    for (const num of numbers) {\r\n      if (isSafe(grid, row, col, num)) {\r\n        grid[row][col] = num;\r\n        if (fill(nextRow, nextCol)) return true;\r\n        grid[row][col] = 0;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  fill();\r\n  return grid;\r\n};\r\n\r\nconst removeCells = (grid, count) => {\r\n  const puzzle = grid.map(r => [...r]);\r\n  let removed = 0;\r\n\r\n  while (removed < count) {\r\n    const row = Math.floor(Math.random() * 9);\r\n    const col = Math.floor(Math.random() * 9);\r\n    if (puzzle[row][col] !== 0) {\r\n      puzzle[row][col] = 0;\r\n      removed++;\r\n    }\r\n  }\r\n\r\n  return puzzle;\r\n};\r\n\r\n// Main function to generate a solvable puzzle\r\nconst generateSudoku = (difficulty = \"easy\") => {\r\n  const fullGrid = generateFullBoard();\r\n\r\n  let blanks;\r\n  switch (difficulty) {\r\n    case \"easy\": blanks = 40; break;\r\n    case \"medium\": blanks = 50; break;\r\n    case \"hard\": blanks = 60; break;\r\n    default: blanks = 50;\r\n  }\r\n\r\n  const puzzle = removeCells(fullGrid, blanks);\r\n\r\n  // Ensure it's still solvable\r\n  const solvable = solveSudoku(puzzle.map(r => [...r]));\r\n  if (!solvable) return generateSudoku(difficulty); // Retry if not solvable\r\n\r\n  const fixedCells = puzzle.map(row => row.map(val => val !== 0));\r\n  return { puzzle, fixedCells };\r\n};\r\n\r\nexport { generateSudoku, solveSudoku, isSafe };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}